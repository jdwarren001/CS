{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww12460\viewh15080\viewkind1
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Aim:
\f1\b0 \
To write some programs using loops, arrays and library functions.\
\
Procedure:\

\f0\b Part A:
\f1\b0 \
Consider an apartment block which has 40 units. The letterboxes for the 40 units are lined up in sequence outside the building, and are numbered 1 to 40. We\'92re going to play with the boxes. Start with all the boxes closed. Next, starting with box 2, open every alternate box (that is, 2, 4, 6, . . .). Next, starting with box 3, change the state of every third box (close the box if it is open, open it if closed). Repeat this for every 4th box, 5th box, etc., until we change the state of the 40th box. At the end of this process, some boxes are open and some are closed. We're going to write a program called ass4A.cpp to determine which.\
\
Firstly, we set up an array (of whichever type you decide would work) to represent the 40 boxes. Of course, we know that C++ refers to array elements from 0, so we'll have to continually refer to array element n-1 when discussing letterbox n. Set the array to indicate that all the boxes are closed. Now perform the process as follows:\
\
    FOR n going from 2 to 40 DO\
        change the state of boxes n, 2n, 3n, 4n, . . .\
At the end of the process, print out which boxes are closed. Make the number of boxes a named constant. Use a value of 150 boxes for the submitted program.\
\

\f0\b Part B:
\f1\b0 \
We're going to write a game program. It's a pencil-and-paper game called countdown. We are going to play against the computer in a race to count down from 501 to 0 by subtracting numbers from the set 1 to 99. But once a particular number has been used, neither of the players can choose it again. The winner is the first to reach 0 exactly, or to force the other player into a no-move situation. Here's a high-level algorithm.\
    initialize flags for all 99 numbers to indicate their availability\
    set the totals for each player to 501\
    the computer goes first half the time leading to an updated total\
    WHILE the game is still going DO\
        ask the player for their number\
        deduct the number from their total\
        generate a computer move\
        update the computer's total\
    Report who won\
Next we have to look at the steps in more detail.\
Firstly the computer going first 
\f0\b half the time
\f1\b0 . How does the program determine that? It needs to toss a coin. Well, we use an approximation of that process \'96 pseudorandom numbers.\
\
There is a function available in the library cstdlib called\
    int rand(void);\
which, each time it is called, returns a different number which can be considered to be independent of the last number it returned. It also has the property that all positive integers are just as likely to be returned. This means that half of them are odd and half are even. So checking whether rand() is odd or even can be used to decide if the computer goes first. \
\
Next, how does the computer select its first move? Well, it might as well just pick any of the numbers from 1 to 99 inclusive. If we take the return value of rand() and mod it by 99 and add 1, we'll get a number between 1 and 99. The property of these (pseudo\'96)random numbers is that again each of these 99 numbers are pretty close to equally likely.\
Once chosen, of course, we have to report the choice, subtract the value from the computer\'92s total, and set the selected number's flag to now unavailable.\
\
Unless the game is over, the game continues.\
\
So what does the computer do to get the player's turn?\
It asks for a number, checks its availability, and asks again if the number is not available. The program must also check to ensure that the number selected does not make the player\'92s total go negative.\
Of course, if there are no legal numbers left for the player to choose, the player will have to admit defeat by entering 0. Once the player's number has been accepted, the program determines the player's total, checking to see if the game is over.\
\
If the game is not over, the program now has to generate the player's turn. This part could be very complicated (and you can embellish this algorithm if you wish, to make it play better). But let's use this pretty simple tactic.\
   1. If the computer can win by selecting an available number, do that.\
   2. If the computer can stop the player from winning by choosing the \
      appropriate number, do that.  Make sure that this number is available \
      and doesn't send the computer's total negative.\
   3. Otherwise, just pick a random number using this approach\
        REPEAT\
            Select a random number from 1 to maximum available to computer\
        UNTIL number is available and legal\
      You may find it useful to check to ensure first that there is a number \
      in the range 1 to the maximum number the computer can choose (either 99 \
      or the computer's total if less than 100).\
Now check whether the game is over. If it is, the loop will terminate and we can also determine who won. Each time a move is made, report the current totals.\
\
Here is an example of a game played against the lecturer's program.\
Let's start with Me = 501   You = 501\
Your turn: 50\
Totals are now  Me = 501   You = 451\
My move is 53\
Totals are now  Me = 448   You = 451\
Your turn: 30\
Totals are now  Me = 448   You = 421\
My move is 14\
Totals are now  Me = 434   You = 421\
Your turn: 90\
Totals are now  Me = 434   You = 331\
My move is 1\
Totals are now  Me = 433   You = 331\
Your turn: 40\
Totals are now  Me = 433   You = 291\
My move is 10\
Totals are now  Me = 423   You = 291\
Your turn: 70\
Totals are now  Me = 423   You = 221\
My move is 71\
Totals are now  Me = 352   You = 221\
Your turn: 35\
Totals are now  Me = 352   You = 186\
My move is 21\
Totals are now  Me = 331   You = 186\
Your turn: 60\
Totals are now  Me = 331   You = 126\
My move is 96\
Totals are now  Me = 235   You = 126\
Your turn: 29\
Totals are now  Me = 235   You = 97\
My move is 97\
Totals are now  Me = 138   You = 97\
Your turn: 2\
Totals are now  Me = 138   You = 95\
My move is 95\
Totals are now  Me = 43    You = 95\
Your turn: 43\
Totals are now  Me = 43    You = 52\
My move is 18\
Totals are now  Me = 25    You = 52\
Your turn: 25\
Totals are now  Me = 25    You = 27\
My move is 19\
Totals are now  Me = 6     You = 27\
Your turn: 27\
You win.\
Note that you decide the style of the output in your program \'96 it does not have to identically match the above sample.\
\
Finally, the function rand() will generate the same sequence of pseudo-random numbers every time the program is run, unless the sequence is initialised using the function\
   void srand(unsigned int);\
at the beginning of the program. The argument of this function is called the seed of the random number generator. This could be a number input at the beginning of the program but is usually some "random" value like the time. We can use the function\
   int time(0);\
from the library ctime. (The function isn't really as described, but for now it can be used that way.) \
So just add the line\
   srand(time(0));\
to your program.\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
CSCI114/203/A5}